import time
import glob
import os
import archinfo
from collections import OrderedDict
import re
import numpy as np
from sklearn.svm import SVC
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from sklearn.metrics import  zero_one_loss, confusion_matrix
from sklearn.preprocessing import StandardScaler
from Disassemblies.Disassembly import *
from Vex import vex
import pyvex


logger = logging.getLogger("MarkovChainMalwareClassifier")
logging.basicConfig(level=logging.INFO)
logger.setLevel(logging.INFO)

MALWARE_PROTO_FILE_PATH= "malware_protos/"
NONMALWARE_PROTO_FILE_PATH= "disassembly_protos/"

NUM_FEATURES= 2

MALWARE_PROTO_FILE_PATH= "malware_protos/"
NONMALWARE_PROTO_FILE_PATH= "disassembly_protos/"


TEST_BINARY_PROTO_FILE_PATH = os.path.join(NONMALWARE_PROTO_FILE_PATH,
                                           "calc.exe_Disassembly_c74f41325775de4777000161a057342cc57a04e8b7be17b06576412eff574dc5.pb.z")



def matprint(mat, fmt="g"):
    col_maxes = [max([len(("{:"+fmt+"}").format(x)) for x in col]) for col in mat.T]
    for x in mat:
        for i, y in enumerate(x):
            print(("{:"+str(col_maxes[i])+fmt+"}").format(y), end="  ")
        print("")


class ClassLabel(Enum):

    MALWARE=1
    NONMALWARE=2
    UNKNOWN=3


class IRCategory(Enum):

    arithmetic = 1
    call = 2
    conditional = 3
    load = 4
    store = 5
    branch = 6
    bit_logic = 7
    bit_shift = 8
    bit_extend = 9
    bit_trunc = 10
    reg_access = 11
    compare = 12
    other = 13


def get_arch_type_from_proc_type(proc_type):

    assert isinstance(proc_type, ProcessorType)

    arch = None
    if proc_type == ProcessorType.x86_64:

        # AMD 64
        arch = archinfo.ArchAMD64()

    elif proc_type == ProcessorType.x86:

        # x86
        arch = archinfo.ArchX86()

    else:
        raise ValueError("Unsupported architecture: '{}'".format(proc_type))

    return arch


class FunctionMetaData(object):

    def __init__(self, disassembly_function, proc_type, class_label=None ):

        assert isinstance(disassembly_function, DisassemblyFunction)
        self._disassembly_function = disassembly_function

        assert isinstance(class_label, ClassLabel)
        self._class_label = class_label

        # Processor type
        assert isinstance(proc_type, ProcessorType)
        self._proc_type = proc_type

        # Anger function
        self._angr_func = None

        # Ordered irsb block
        self._irsb_block_ordered_map = None

        # Arch information
        self._arch = get_arch_type_from_proc_type(self._proc_type)

        # Markov transition matrix
        self._markov_transition_matrix = None

    def _generate_markov_tran_matrix(self):

        # Iterate through the ordered map where the key is the
        # start address of that ordered map

        number_of_categories = len(IRCategory)

        markov_tran_matrix = np.zeros(shape=(number_of_categories, number_of_categories))

        # The ir category of the last statement
        previous_ir_category = None

        for key in self.irsb_block_ordered_map:

            # Get the irsb associated with this key(start address)
            irsb = self.irsb_block_ordered_map[key]

            # Iterate through each statement in irsb
            for stmt in irsb.statements:

                # Skip over IMark statements
                if isinstance(stmt, pyvex.stmt.IMark):
                    continue

                # Skip over AbiHint statements
                elif isinstance(stmt, pyvex.stmt.AbiHint):
                    continue

                # Get the ir category from the statement
                current_ir_category = FunctionMetaData.get_ir_category_from_statement(stmt)

                if previous_ir_category is None:

                    # This is the first vex ir statement of the function
                    previous_ir_category = current_ir_category
                    continue

                # Update transition matrix entry
                markov_tran_matrix[previous_ir_category.value-1, current_ir_category.value-1] +=1

                previous_ir_category = current_ir_category

        # Normalize the transition matrix so that each row sums up to 1
        for row in range(number_of_categories):

            # Normalize each row so that it sums up to 1
            row_sum = np.sum(markov_tran_matrix[row,:])
            if row_sum >0:
                # Only scale the row if it has positive entries. Otherwise no need
                markov_tran_matrix[row, :] *= (1.0/row_sum)

        return markov_tran_matrix

    @staticmethod
    def get_ir_category_from_statement(stmt):


        ir_category =  IRCategory.other

        # ** Exit **
        if isinstance(stmt, pyvex.stmt.Exit):

            ir_category = IRCategory.branch

        # ** Put **
        elif isinstance(stmt, pyvex.stmt.Put):

            ir_category = IRCategory.reg_access

        # ** Store **
        elif isinstance(stmt, pyvex.stmt.Store):

            ir_category = IRCategory.store

        # ** WrTmp **
        elif isinstance(stmt, pyvex.stmt.WrTmp):

            # Get the expression
            expression_data = stmt.data

            # Get the ir category of this expression
            ir_category = FunctionMetaData.get_ir_category_from_expression(expression_data)

        else:

            logger.warning("Unsupported statement of type '{}'. Will default IR category to IRCategory.other".format(type(stmt)))
            ir_category = IRCategory.other

        return ir_category

    @staticmethod
    def get_ir_category_from_expression(expression_data):

        # Get the expression tag
        expression_tag = expression_data.tag

        # get the expression class from the expression tag
        expr_class = pyvex.expr.tag_to_expr_class(expression_tag)

        # The ir category that this expression falls under
        ir_category = IRCategory.other

        # Handle based on the expression class type and

        # ** Binop **
        if expr_class == pyvex.expr.Binop:

            ir_category = FunctionMetaData.get_ir_category_from_bin_op(expression_data)

        # ** Get **
        elif expr_class == pyvex.expr.Get:

            ir_category = IRCategory.reg_access

        # ** Load **
        elif expr_class == pyvex.expr.Load:

            ir_category = IRCategory.load

        # ** RdTmp **
        elif expr_class == pyvex.expr.RdTmp:

            ir_category = IRCategory.other

        # ** Unop **
        elif expr_class == pyvex.expr.Unop:

            ir_category = FunctionMetaData.get_ir_category_from_unop(expression_data)

        # ** CCall **
        elif expr_class == pyvex.expr.CCall:

            ir_category = IRCategory.other

        elif expr_class == pyvex.expr.Const:

            ir_category = IRCategory.other

        else:
            logger.warning("Unsupported expression class '{}' Will default to IRCategory.other.".format(str(expr_class)))
            ir_category = IRCategory.other

        return ir_category

    @staticmethod
    def get_ir_category_from_bin_op(bin_op_expr_data):

        # The ir category that this binary operation falls under
        ir_category = None

        bin_op = bin_op_expr_data.op

        if "Add" in bin_op:

            ir_category = IRCategory.arithmetic

        elif "And" in bin_op:

            ir_category = IRCategory.bit_logic

        elif "Sub" in bin_op:

            ir_category = IRCategory.arithmetic

        elif "Mul" in bin_op:

            ir_category = IRCategory.arithmetic

        elif "Cmp" in bin_op:

            ir_category = IRCategory.compare

        elif "Iop_Sh" in bin_op:

            ir_category = IRCategory.bit_shift

        elif "Or" in bin_op:

            ir_category = IRCategory.bit_logic

        elif "Sar" in bin_op:

            ir_category = IRCategory.bit_logic

        elif "Xor" in bin_op:

            ir_category = IRCategory.bit_logic

        elif re.compile(".*Iop_[VIFS]?(\d*)[HS]?L?to[VIF]?(\d*)[S]?").match(bin_op) is not None:

            # e.g. 32HLto64 ; F64toF32
            p = re.compile(".*Iop_[VIFS]?(\d*)[HS]?L?to[VIF]?(\d*)[S]?").match(bin_op)

            logger.debug("bin_op: '{}'".format(bin_op))

            operand_0 = int(p.group(1), 0)

            operand_1 = int(p.group(2), 0)

            if operand_0 < operand_1:

                ir_category = IRCategory.bit_extend

            elif operand_0 > operand_1:

                ir_category = IRCategory.bit_trunc

            else:
                # Case with equality (i.e. operand_0 == operand_1)
                ir_category = IRCategory.other

        else:
            logger.warning("Unsupported binary operation '{}'. Defaulting IR category to IRCategory.other".format(bin_op))
            ir_category = IRCategory.other

        return ir_category

    @staticmethod
    def get_ir_category_from_unop(unop_expr_data):

        # The ir category that this read temp expression falls under
        ir_category = None

        unary_op = unop_expr_data.op

        # # Handle the extend and truncate unary expressions
        # # e.g. "Iop_64HIto32", "Iop_I32StoF64"
        p = re.compile(".*Iop_[VH]?[FI]?(\d*)[SUH]?[I]?to[FV]?(\d*)")
        m = p.match(unary_op)
        if m:
            first_int = int(m.group(1),0)
            second_int = int(m.group(2),0)

            if first_int < second_int:
                ir_category = IRCategory.bit_extend

            else:
                ir_category = IRCategory.bit_trunc

        elif "Not" in  unary_op:

            ir_category = IRCategory.bit_logic

        else:

            logger.warning("Unsupported unary operation '{}'. "
                           "Defaulting IR category to be IRCategory.other ".format(unary_op))

            ir_category = IRCategory.other

        return ir_category

    @property
    def angr_func(self):

        if self._angr_func is None:

            self._angr_func = vex.AngrFunction(self._disassembly_function, self._arch)

        return self._angr_func

    @property
    def name(self):

        return self._disassembly_function.name

    @property
    def markov_transition_matrix(self):

        if self._markov_transition_matrix is None:

            self._markov_transition_matrix = self._generate_markov_tran_matrix()

        return self._markov_transition_matrix

    @property
    def irsb_block_ordered_map(self):

        """
        Returns a irsb block ordered map where irsbs are ordered
        based on their start address from low to high

        """
        if self._irsb_block_ordered_map is None:

            irsb_unordered_map = dict()

            for block in self.angr_func.blocks:
                # Get the irsb
                irsb = block.vex

                # Get the block address
                block_addr = block.addr

                # Add the irsb to the map, where the key is the irsb address
                irsb_unordered_map[block_addr] = irsb

            irsb_ordered_map = OrderedDict()

            for block_addr in sorted(irsb_unordered_map):
                irsb_ordered_map[block_addr] = irsb_unordered_map[block_addr]

            self._irsb_block_ordered_map = irsb_ordered_map

        return self._irsb_block_ordered_map

    @property
    def class_label(self):
        return self._class_label

    @property
    def proc_type(self):
        return self._proc_type


class BinaryMetaData(object):

    def __init__(self, class_label, disassembly_binary):

        self._class_label = class_label
        assert isinstance(class_label, ClassLabel)

        self._disassembly_binary = disassembly_binary
        assert isinstance(disassembly_binary, DisassemblyBinary)

        self._binary_name = disassembly_binary.binary_name

        self._function_metadata_list = None

    def _generate_func_metadata_list(self):

        # Function inherits the class label of the binary
        # (e.g. If the binary is marked non-malware, then so are the functions that are
        #       associated with that binary)
        func_meta_data_list = [FunctionMetaData(dis_function, self._disassembly_binary.proc_type, self.class_label)
                               for dis_function in self._disassembly_binary.disassembly_func_list]

        return func_meta_data_list

    @property
    def class_label(self):

        return self._class_label

    @property
    def binary_name(self):
        return self._binary_name

    @property
    def function_meta_data_list(self):

        if self._function_metadata_list is None:

            logger.info("Generating function meta data for binary:'{}'".format(self.binary_name))

            self._function_metadata_list = self._generate_func_metadata_list()

        return self._function_metadata_list


class MarkovChainMalwareClassifier(object):

    def __init__(self):

        self._is_initialized = False

        self._is_model_trained = False

        self._binary_meta_data_list = []

        self._num_binaries = None

        self._feature_matrix = None

        self._labels = None

        self._svm = None

    def initialize(self):

        if not self._is_initialized:

            self.load_binary_meta_data_obs()

            self._num_binaries = len(self._binary_meta_data_list)

            self._is_initialized = True

            self._svm = None


        return self._is_initialized

    def _get_labels(self):

        labels = np.zeros(self._num_binaries, dtype=np.int) + 1
        logger.warning("@Todo: Update the labels array with the appropriate label value for each entry in array"
                       "where Malware==>1 and NonMalware==>2")

        return labels

    def _generate_feature_matrix(self):

        # Number of features for each function is number of entries in the transition matrix
        number_of_features = len(IRCategory)**2

        feature_matrix = np.zeros(shape=(self._num_binaries, number_of_features))
        logger.warning("@Todo: Need to update the feature matrix appropriately")

        for binary_meta_data in self._binary_meta_data_list:

            for function_meta_data in binary_meta_data.function_meta_data_list:

                print("\n({}) Markov transition matrix:".format(function_meta_data.name))
                matprint(function_meta_data.markov_transition_matrix)

        return feature_matrix

    def load_binary_meta_data_obs(self):

        for binary_directory_path in [NONMALWARE_PROTO_FILE_PATH, MALWARE_PROTO_FILE_PATH]:

            binary_type = ClassLabel.MALWARE
            if binary_directory_path == NONMALWARE_PROTO_FILE_PATH:

                binary_type = ClassLabel.NONMALWARE

            for binary_file_path in glob.glob(os.path.join(binary_directory_path, '*.pb.z')):

                binary_base_name = os.path.basename(binary_file_path)

                disassembly_binary = DisassemblyBinary.deserialize_from_file(binary_file_path)
                assert isinstance(disassembly_binary, DisassemblyBinary)
                logger.info("({}) Loaded binary proto: '{}'\n".format(binary_type,binary_base_name))

                binary_meta_data = BinaryMetaData(binary_type,disassembly_binary)

                self._binary_meta_data_list.append(binary_meta_data)

                logger.warning("@Todo: remove break; only needed for temp debugging so "
                               "that functionality can be demonstrated quickly")
                break

    def perform_classification(self):

        # Make sure object initialized
        self.initialize()

        if self._feature_matrix is None:

            self._feature_matrix = self._generate_feature_matrix()

        if self._labels is None:

            self._labels = self._get_labels()

        logger.warning("@Todo: Comment out return once EVERYTHING else has been implemented")
        return

        standard_scaler = StandardScaler().fit(self._feature_matrix)
        feature_matrix_std  = standard_scaler.transform(self._feature_matrix)

        print("labels:{}".format(self._labels))

        self._svm = SVC(kernel='rbf', random_state=0)
        self._svm.fit(feature_matrix_std , self._labels)

        pred_y = self._svm.predict(feature_matrix_std )

        error = zero_one_loss(self._labels, pred_y)

        print("Error:{}".format(error))

        results = confusion_matrix(self._labels, pred_y)

        print("Confusion Matrix:\n{}".format(results))

        self._is_model_trained = True

    def predict_if_malware(self, target_disassembly_func, proc_type):

        assert isinstance(target_disassembly_func, DisassemblyFunction)
        assert isinstance(proc_type, ProcessorType)

        logger.warning("will need to update the below classification label"
                       "to be the determined class o ")
        func_class_label = ClassLabel.UNKNOWN

        if not self._is_model_trained:
            self.perform_classification()

        target_arch = get_arch_type_from_proc_type(proc_type)

        target_disassembly_func_meta_data = FunctionMetaData(target_disassembly_func,
                                                             proc_type,
                                                             ClassLabel.UNKNOWN)

        logger.warning("@Need to implement the rest of logic. "
                       "Function should return an enum from  ClassLabel.")

        return func_class_label


def test_harness():

    markov_chain_malware_classifier = MarkovChainMalwareClassifier()

    markov_chain_malware_classifier.perform_classification()

    # LET's get a test disassembly and test one of its functions against our classifier
    test_disassembly_binary = DisassemblyBinary.deserialize_from_file(TEST_BINARY_PROTO_FILE_PATH)
    proc_type = test_disassembly_binary.proc_type

    for target_disassembly_func in test_disassembly_binary.disassembly_func_list:

        func_class_label = markov_chain_malware_classifier.predict_if_malware(target_disassembly_func, proc_type)

        logger.info("Function:'{}' Class Label: '{}'".format(target_disassembly_func.name,
                                                             func_class_label.name))

        break
        logger.warning("@Todo: Remove this break if you want to check if each function"
                       "in the test binary is classified as malware")


if __name__ == "__main__":
    test_harness()

























